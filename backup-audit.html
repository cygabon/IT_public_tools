<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>backup-audit — QCM sauvegarde (audit + plan) </title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f1624;
      --panel2:#0c1320;
      --text:#e8edf7;
      --muted:#a9b4c7;
      --faint:#6f7b91;
      --line:#1c2a44;
      --ok:#31d0aa;
      --warn:#ffcc66;
      --bad:#ff6b6b;
      --accent:#8ab4ff;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --r: 16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 600px at 30% -10%, rgba(138,180,255,.18), transparent 60%),
        radial-gradient(900px 500px at 90% 0%, rgba(49,208,170,.14), transparent 60%),
        radial-gradient(900px 500px at 20% 110%, rgba(255,204,102,.10), transparent 60%),
        var(--bg);
      color:var(--text);
      line-height:1.35;
    }
    .wrap{max-width: 1220px;margin: 0 auto;padding: 18px 14px 60px}
    header{display:flex;gap:14px;align-items:flex-start;justify-content:space-between;margin-bottom:12px}
    @media (max-width: 1100px){header{flex-direction:column}}
    .brand{display:flex;gap:12px;align-items:flex-start}
    .dot{
      width:14px;height:14px;border-radius:999px;
      background: linear-gradient(135deg, var(--accent), var(--ok));
      box-shadow: 0 0 0 6px rgba(138,180,255,.10);
      margin-top:7px;flex:0 0 auto;
    }
    h1{margin:0;font-size:19px;letter-spacing:.2px}
    .subtitle{margin:6px 0 0;color:var(--muted);font-size:13px;max-width:760px}
    .top-actions{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    button{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      color:var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .05s ease, border-color .15s ease, background .15s ease;
      box-shadow: 0 8px 18px rgba(0,0,0,.18);
      font-weight: 800;
      font-size: 13px;
    }
    button:hover{border-color: rgba(138,180,255,.45)}
    button:active{transform: translateY(1px)}
    button.secondary{background: transparent; box-shadow:none}

    .grid{display:grid;grid-template-columns: 310px 1.25fr .9fr;gap:14px;align-items:start}
    @media (max-width: 1150px){.grid{grid-template-columns:1fr}}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .hd{
      padding: 12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent);
    }
    .hd h2{margin:0;font-size:13px;letter-spacing:.2px}
    .body{padding: 12px 14px}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding: 6px 10px;border-radius: 999px;border:1px solid var(--line);
      color: var(--muted);font-size: 12px;white-space:nowrap;
    }
    .note{color:var(--muted);font-size:13px;margin:0 0 10px}
    .divider{height:1px;background: var(--line);margin: 12px 0}
    .small{font-size:12px;color:var(--muted)}
    .mutedline{color:var(--faint);font-size:12px}

    /* NAV */
    .navlist{display:flex;flex-direction:column;gap:8px}
    .navbtn{
      width:100%;
      text-align:left;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.14);
      color: var(--text);
      cursor:pointer;
      display:flex;justify-content:space-between;align-items:center;gap:10px;
      font-weight:850;font-size:13px;
    }
    .navbtn:hover{border-color: rgba(138,180,255,.45)}
    .navmeta{display:flex;align-items:center;gap:8px}
    .navhint{font-size:12px;color:var(--muted);font-weight:750}
    .check{
      width:18px;height:18px;border-radius:7px;
      border:1px solid rgba(255,255,255,.12);
      display:grid;place-items:center;
      background: rgba(255,255,255,.02);
      flex:0 0 auto;
    }
    .check.ok{border-color: rgba(49,208,170,.55); background: rgba(49,208,170,.12)}
    .check svg{display:none}
    .check.ok svg{display:block}

    .navactions{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .navactions button{padding:8px 10px;font-size:12px}

    /* Categories */
    .cat{
      border:1px solid var(--line);
      background: rgba(0,0,0,.14);
      border-radius: 14px;
      overflow:hidden;
      margin: 12px 0;
    }
    .cat-hd{
      padding: 12px 12px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      user-select:none;
      background: linear-gradient(180deg, rgba(255,255,255,.03), transparent);
    }
    .cat-title{display:flex;flex-direction:column;gap:3px}
    .cat-title .t{font-weight:950;font-size:13px}
    .cat-title .s{color:var(--muted);font-size:12px}
    .cat-bd{padding: 10px 12px 12px}
    .bucket{
      border-top:1px solid rgba(255,255,255,.08);
      padding-top: 10px;
      margin-top: 10px;
    }
    .bucket:first-child{border-top:none;padding-top:0;margin-top:0}

    /* Questions as "cards" that collapse when answered */
    .q{
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.16);
      border-radius: 14px;
      padding: 12px 12px 10px;
      margin: 10px 0;
      transition: opacity .18s ease, transform .18s ease, max-height .22s ease, margin .22s ease, padding .22s ease;
      max-height: 560px;
      overflow:hidden;
    }
    .q.done{
      opacity: .25;
      transform: translateY(-2px);
      max-height: 0px;
      padding-top: 0;
      padding-bottom: 0;
      margin-top: 0;
      margin-bottom: 0;
      border-width: 0;
    }
    .qhead{
      display:flex;justify-content:space-between;gap:12px;align-items:flex-start;margin-bottom: 8px;
    }
    .qtitle{margin:0;font-size:13px;color:var(--text);font-weight:900}
    .qmeta{color: var(--faint);font-size: 12px;white-space:nowrap;display:flex;align-items:center;gap:8px}

    .opts{display:grid;gap:8px;margin: 10px 0 6px}
    label.opt{
      display:flex;gap:10px;align-items:flex-start;
      padding: 10px 10px;border-radius: 12px;
      border: 1px solid rgba(255,255,255,.06);
      background: rgba(255,255,255,.02);
      cursor:pointer;
      transition: border-color .15s ease, background .15s ease;
    }
    label.opt:hover{border-color: rgba(138,180,255,.35);background: rgba(138,180,255,.05)}
    input[type="radio"]{margin-top:2px;accent-color: var(--accent)}

    .hint{margin: 8px 0 0;color: var(--faint);font-size: 12px}

    /* A "completed" area to keep answered accessible without scrolling roulette */
    .completed-list{display:flex;flex-direction:column;gap:8px}
    details{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 14px;
      overflow:hidden;
    }
    summary{
      list-style:none;
      cursor:pointer;
      padding: 10px 10px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      user-select:none;
      font-weight:900;
      font-size:13px;
    }
    summary::-webkit-details-marker{display:none}
    .sum-meta{display:flex;gap:8px;align-items:center}
    .badgeMini{
      font-size:11px;
      padding: 5px 9px;border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      color: var(--muted);
      background: rgba(255,255,255,.02);
      white-space:nowrap;
    }
    .ansItem{
      padding: 10px 10px;
      border-top:1px solid rgba(255,255,255,.08);
      color: var(--muted);
      font-size: 13px;
    }
    .ansItem b{color:var(--text)}
    .ansItem .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:6px}
    .btnlink{
      padding: 7px 9px;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.02);
      cursor:pointer;
      color: var(--text);
      font-weight:850;
      font-size:12px;
    }
    .btnlink:hover{border-color: rgba(138,180,255,.45)}
    .btnlink.danger{border-color: rgba(255,107,107,.35)}
    .btnlink.danger:hover{border-color: rgba(255,107,107,.70)}

    /* Score side */
    .kpis{display:grid;grid-template-columns: 1fr 1fr;gap:10px}
    .kpi{border: 1px solid var(--line);border-radius: 14px;padding: 10px 10px;background: rgba(0,0,0,.16)}
    .kpi .t{color: var(--muted);font-size: 12px;margin-bottom: 4px}
    .kpi .v{font-size: 18px;font-weight: 1000;letter-spacing:.2px}
    .bar{height: 10px;border-radius: 999px;background: rgba(255,255,255,.06);border: 1px solid rgba(255,255,255,.06);overflow:hidden;margin-top: 10px}
    .bar > div{height:100%;width: 0%;background: linear-gradient(90deg, var(--bad), var(--warn), var(--ok));transition: width .25s ease}
    .level{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding: 10px 12px;border-radius: 14px;border: 1px solid var(--line);
      background: rgba(0,0,0,.16); margin-top: 12px;
    }
    .badge{
      padding: 6px 10px;border-radius: 999px;font-size: 12px;font-weight: 1000;
      letter-spacing:.2px;border:1px solid rgba(255,255,255,.12);
    }
    .badge.ok{background: rgba(49,208,170,.15); color: var(--ok)}
    .badge.warn{background: rgba(255,204,102,.15); color: var(--warn)}
    .badge.bad{background: rgba(255,107,107,.15); color: var(--bad)}
    .rec{padding: 12px 12px;border-radius: 14px;border: 1px solid var(--line);background: rgba(0,0,0,.16); margin-top: 12px}
    .rec h3{margin:0 0 8px;font-size: 13px;letter-spacing:.2px}
    ul{margin:0;padding-left:18px;color:var(--muted);font-size:13px}
    li{margin: 6px 0}
    .tagrow{display:flex;gap:8px;flex-wrap:wrap;margin-top: 8px}
    .tag{font-size:11px;color: var(--muted);border: 1px solid rgba(255,255,255,.10);border-radius: 999px;padding: 6px 10px;background: rgba(255,255,255,.02)}

    /* Radar */
    .radar{
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 10px;
      background: rgba(0,0,0,.16);
      margin-top: 10px;
    }
    canvas{max-width:100%;height:auto;display:block}

    /* Tooltip popup */
    .info{
      width:18px;height:18px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.03);
      display:grid;place-items:center;
      cursor:pointer; flex:0 0 auto;
    }
    .info:hover{border-color: rgba(138,180,255,.45)}
    .tip{
      position: fixed;
      z-index: 1000;
      max-width: 440px;
      padding: 12px 12px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: rgba(15,22,36,.96);
      box-shadow: var(--shadow);
      display:none;
    }
    .tip.show{display:block}
    .tip .tt{font-weight:1000;font-size:13px;margin:0 0 6px}
    .tip .tx{color:var(--muted);font-size:13px;margin:0}
    .tip .ex{margin-top:10px;border-top:1px solid rgba(255,255,255,.08);padding-top:10px;color:var(--muted);font-size:12px}
    .tip .ex b{color:var(--text)}
    .tip .close{
      position:absolute; top:10px; right:10px;
      width:28px;height:28px;border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.02);
      color: var(--text);
      cursor:pointer;
      font-weight:1000;
    }

    .toast{
      position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
      background: rgba(15,22,36,.92);
      border:1px solid var(--line);
      border-radius: 999px;
      padding: 10px 12px;
      color: var(--text);
      box-shadow: var(--shadow);
      display:none;
      gap:10px;align-items:center;
      max-width: 92vw;
      z-index: 50;
      font-size: 13px;
    }
    .toast.show{display:flex}
    .toast .k{color: var(--muted);font-weight:900}
    .toast .v{font-weight:1000}
  </style>
</head>

<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="dot" aria-hidden="true"></div>
      <div>
        <h1>backup-audit — QCM (les questions disparaissent quand vous répondez)</h1>
        <p class="subtitle">
          Objectif : libérer l’écran au fur et à mesure. Une question répondue se replie dans “Réponses déjà données”.
          Si vous doutez : prenez l’option la plus défavorable. Sinon le score ment.
        </p>
      </div>
    </div>
    <div class="top-actions">
      <button id="btnScore">Calculer</button>
      <button class="secondary" id="btnExport">Exporter</button>
      <button class="secondary" id="btnReset">Réinitialiser</button>
    </div>
  </header>

  <div class="grid">

    <!-- LEFT -->
    <aside class="card" aria-label="Navigation & réponses">
      <div class="hd">
        <h2>Navigation & état</h2>
        <span class="pill"><span id="answered">0</span>/<span id="total">0</span></span>
      </div>
      <div class="body">
        <div class="note">
          Les catégories se cochent automatiquement quand elles sont complètes.
        </div>

        <div class="navlist" id="nav"></div>

        <div class="navactions">
          <button class="secondary" id="openAll">Tout ouvrir</button>
          <button class="secondary" id="closeAll">Tout fermer</button>
          <button class="secondary" id="showAllQs" title="Ré-affiche temporairement toutes les questions répondue">Afficher toutes les questions</button>
        </div>

        <div class="divider"></div>

        <div class="section-title" style="display:flex;justify-content:space-between;align-items:center">
          <span>Réponses déjà données</span>
          <span class="mutedline" id="answeredHint">—</span>
        </div>

        <div class="completed-list" id="completed"></div>

        <div class="divider"></div>
        <div class="small">
          Cliquez une réponse pour la revoir et la modifier (bouton “Modifier”).
          Les popups “i” expliquent les notions (3-2-1, immutabilité, etc.).
        </div>
      </div>
    </aside>

    <!-- MAIN -->
    <main class="card" aria-label="Questionnaire">
      <div class="hd">
        <h2>Questions restantes</h2>
        <span class="pill">celles-ci disparaissent après réponse</span>
      </div>
      <div class="body" id="cats"></div>
    </main>

    <!-- RIGHT -->
    <aside class="card" aria-label="Score et toile">
      <div class="hd">
        <h2>Toile de maîtrise</h2>
        <span class="pill">0 → 100</span>
      </div>
      <div class="body">
        <div class="kpis">
          <div class="kpi">
            <div class="t">Score total</div>
            <div class="v" id="score">—</div>
          </div>
          <div class="kpi">
            <div class="t">Couverture</div>
            <div class="v" id="coverage">—</div>
          </div>
        </div>
        <div class="bar"><div id="barFill"></div></div>

        <div class="level">
          <div>
            <div class="mutedline">Niveau</div>
            <div class="v" id="levelText" style="font-weight:1000">—</div>
          </div>
          <div class="badge bad" id="badge">—</div>
        </div>

        <div class="radar">
          <div class="mutedline" id="radarHint" style="margin-bottom:8px;">
            Répondez puis calculez : les creux = angles morts.
          </div>
          <canvas id="radar" width="520" height="460"></canvas>
        </div>

        <div class="rec">
          <h3>Ce que ça suggère</h3>
          <ul id="insights">
            <li>Le score ne prouve pas la sécurité : il montre vos zones faibles.</li>
            <li>Les “creux” sont souvent là où vous pensez être bon sans preuve.</li>
          </ul>
          <div class="tagrow" id="tags"></div>
        </div>

        <div class="rec">
          <h3>Priorités (actions)</h3>
          <ul id="priorities"><li>—</li></ul>
        </div>
      </div>
    </aside>

  </div>
</div>

<!-- Tooltip -->
<div class="tip" id="tip" role="dialog" aria-hidden="true">
  <button class="close" id="tipClose" title="Fermer">×</button>
  <p class="tt" id="tipTitle">—</p>
  <p class="tx" id="tipText">—</p>
  <div class="ex" id="tipExtra" style="display:none"></div>
</div>

<div class="toast" id="toast" role="status" aria-live="polite">
  <span class="k">Score</span> <span class="v" id="toastScore">—</span>
  <span class="mutedline" id="toastHint"></span>
</div>

<script>
  const $ = (s) => document.querySelector(s);
  const $$ = (s) => Array.from(document.querySelectorAll(s));

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[s]));
  }

  // Axes de la toile
  const AXES = [
    { key:"Gouvernance", label:"Gouvernance" },
    { key:"Résilience",  label:"Résilience" },
    { key:"Sécurité",    label:"Sécurité" },
    { key:"Restauration",label:"Restauration" },
    { key:"Exploitation",label:"Exploitation" },
    { key:"Couverture",  label:"Couverture" },
    { key:"Design",      label:"Design" },
    { key:"Conformité",  label:"Conformité" },
  ];

  // Glossaire
  const GLOSSARY = {
    "321": {
      title: "Règle 3-2-1 et variantes (scorées)",
      text: "La base 3-2-1 : 3 copies, 2 supports, 1 hors site. Les variantes ajoutent de la résistance au ransomware et aux erreurs.",
      extra: `
        <b>Variante(s) :</b><br>
        • <b>3-2-1</b> : base.<br>
        • <b>3-2-1-1</b> : +1 copie <i>offline ou immuable</i> (fort contre ransomware).<br>
        • <b>3-2-1-1-0</b> : +0 erreur via <i>vérifs/tests</i> (restauration prouvée).<br>
        • <b>4-3-2</b> : plus strict (souvent pour environnements sensibles).<br>
        <b>Doute utile :</b> “hors site” mais même tenant/compte/identité = pas une vraie séparation.
      `
    },
    "immut": {
      title: "Immutabilité / WORM",
      text: "WORM/Object Lock : impossibilité de modifier/supprimer avant une date. Essentiel contre ransomware.",
      extra: "<b>Doute utile :</b> si l’admin backup peut désactiver/supprimer facilement, la protection est fragile."
    },
    "domain": {
      title: "Backup server dans le domaine",
      text: "Si le serveur de backup est joint au domaine, un compromission AD peut mener à la destruction des sauvegardes.",
      extra: "<b>Doute utile :</b> l’attaquant vise AD puis backup. Votre design doit casser cette chaîne."
    },
    "av": {
      title: "Antivirus/EDR sur serveur de backup",
      text: "Un AV/EDR mal configuré peut casser les jobs… mais l’absence totale peut rendre le serveur de backup trivial à compromettre.",
      extra: "<b>Doute utile :</b> l’objectif est un contrôle adapté (whitelists, monitoring), pas “installer un agent et prier”."
    }
  };

  // Helpers
  function opt(label, score, tags=[], priority=null, extra=null){
    return { label, score, tags, priority, extra };
  }
  function q(id, title, weight, explainId, axisKey, mode, hint, options){
    return { id, title, weight, explainId, axisKey, mode, hint, options };
  }

  // 3-2-1 variants with score add-ons (applied only if base question = "Oui")
  // Add-on is capped so that total doesn't exceed the question weight.
  const VARIANTS_321 = [
    { key:"321",       label:"3-2-1",         desc:"base", add: 0 },
    { key:"321-1",     label:"3-2-1-1",       desc:"+1 offline/immuable", add: 2 },
    { key:"321-1-0",   label:"3-2-1-1-0",     desc:"+1 offline/immuable +0 erreur (vérifs)", add: 4 },
    { key:"432",       label:"4-3-2",         desc:"plus strict (copies/supports/hors site)", add: 2 },
    { key:"gfs",       label:"GFS",           desc:"quotidien/hebdo/mensuel (rétention)", add: 1 }
  ];

  // Structure par catégories (avec questions "cassantes" ajoutées)
  const CATS = [
    {
      id:"cat-audit-gouv",
      title:"Audit — Gouvernance & exigences",
      subtitle:"objectifs, périmètre, rétention, conformité",
      questions: [
        q("a1","RPO/RTO : objectifs chiffrés, documentés, validés ?",6,null,"Gouvernance","Audit","Sans objectifs, vous ne savez pas si c’est suffisant.", [
          opt("Oui, validés + documentés + revus",6,["Gouvernance"]),
          opt("Partiel (approx / non validé)",3,["Gouvernance"],"Formaliser RPO/RTO avec le métier et les rendre traçables."),
          opt("Non / inconnu",0,["Gouvernance"],"Définir RPO/RTO : sans ça, vous pilotez à l’aveugle.")
        ]),
        q("a2","Inventaire & criticité : savez-vous ce qui est critique et qui en est propriétaire ?",6,null,"Couverture","Audit","Sans inventaire, vous sauvegardez souvent “ce qui est visible”.", [
          opt("Oui (inventaire, criticité, owners)",6,["Couverture"]),
          opt("Partiel",3,["Couverture"],"Faire inventaire + classification + owners (données, apps, secrets, SaaS)."),
          opt("Non",0,["Couverture"],"Dresser inventaire/criticité : sinon la sauvegarde couvrira mal.")
        ]),
        q("a3","Rétention : règles définies (technique + légal) et maîtrisées ?",6,null,"Conformité","Audit","Trop court = pertes. Trop long = risques + coûts.", [
          opt("Oui (politiques par type + revue)",6,["Conformité","Gouvernance"]),
          opt("Partiel (par défaut)",3,["Conformité"],"Définir rétention par type de données + contraintes légales."),
          opt("Non / inconnu",0,["Conformité"],"Définir une rétention : sinon c’est arbitraire.")
        ]),
      ]
    },
    {
      id:"cat-audit-res",
      title:"Audit — Résilience & architecture",
      subtitle:"3-2-1 scoré, hors site, offline/air-gap",
      questions: [
        q("a4","Stratégie 3-2-1 : laquelle appliquez-vous réellement ?",12,"321","Résilience","Audit","Si tout est dans le même périmètre, un incident peut tout emporter.", [
          // Score base intentionally not max: variants will upgrade
          opt("Oui, on applique une stratégie (je peux préciser laquelle)",8,["Résilience"],null,{ show321Variants:true }),
          opt("Partiel (hors site mais séparation discutable)",4,["Résilience"],"Assurer séparation réelle : comptes/tenants, identités, support, site."),
          opt("Non",0,["Résilience"],"Mettre 3-2-1 (idéalement 3-2-1-1-0) avant de vous rassurer.")
        ]),
        q("a5","Hors site : la copie externe est-elle indépendante (tenant/compte/identités) ?",8,null,"Résilience","Audit","“Hors site” mais mêmes droits = pas une vraie séparation.", [
          opt("Oui (compte/tenant séparé + accès limité)",8,["Résilience"]),
          opt("Partiel",4,["Résilience"],"Séparer comptes/tenants/clefs/identités pour réduire le blast radius."),
          opt("Non / inconnu",0,["Résilience"],"Créer une copie hors site réellement indépendante.")
        ]),
        q("a6","Copie offline/air-gap : avez-vous une copie difficilement atteignable en cas de compromission ?",8,null,"Résilience","Audit","Sans copie isolée, vous dépendez d’un seul scénario.", [
          opt("Oui (offline/isolée) + procédure",8,["Résilience","Sécurité"]),
          opt("Partiel (isolée mais accessible via mêmes identités)",4,["Résilience"],"Mettre une vraie isolation (identités, réseau, procédure)."),
          opt("Non",0,["Résilience"],"Ajouter une copie offline/air-gap ou immuable.")
        ]),
      ]
    },
    {
      id:"cat-audit-sec",
      title:"Audit — Sécurité (questions cassantes)",
      subtitle:"immutabilité, AD, AV/EDR, séparation des pouvoirs",
      questions: [
        q("a7","Immutabilité/WORM : vos sauvegardes sont-elles protégées contre suppression/chiffrement ?",10,"immut","Sécurité","Audit","Si un attaquant peut détruire les backups, vous n’avez pas de plan B.", [
          opt("Oui (WORM/Object Lock) + vérifié",10,["Sécurité"]),
          opt("Partiel",5,["Sécurité"],"Ajouter immutabilité + séparation des identités + journaux."),
          opt("Non / inconnu",0,["Sécurité"],"Mettre des sauvegardes immuables et isolées : priorité ransomware.")
        ]),
        // Cassante #1
        q("a8","Cassant : votre serveur de backup est-il joint au domaine (AD) ?",10,"domain","Sécurité","Audit","Si oui, vous augmentez fortement le risque d’effet domino AD → backup.", [
          opt("Non, serveur de backup hors domaine + identités dédiées",10,["Sécurité","Résilience"]),
          opt("Partiel (joint mais durci / comptes séparés)",4,["Sécurité"],"Sortir le serveur de backup du domaine ou isoler fortement (identités, réseau, MFA, bastion)."),
          opt("Oui, joint au domaine (classique)",0,["Sécurité"],"Priorité : casser la chaîne AD→backup (hors domaine / isolation / comptes dédiés).")
        ]),
        // Cassante #2
        q("a9","Cassant : le dépôt backup (repo) est-il accessible en écriture avec des identifiants “courants” (admins/domain admin) ?",10,null,"Sécurité","Audit","Si oui : en compromission, le repo est une cible facile.", [
          opt("Non (accès restreint, comptes dédiés, MFA, traces)",10,["Sécurité"]),
          opt("Partiel",4,["Sécurité"],"Réduire le blast radius : comptes dédiés, séparation, verrouillage, journaux hors de portée."),
          opt("Oui / inconnu",0,["Sécurité"],"Retirer l’accès en écriture aux identités courantes : sinon le repo tombe.")
        ]),
        // Cassante #3 (AV/EDR)
        q("a10","Cassant : AV/EDR sur le serveur de backup, est-ce maîtrisé (exceptions, surveillance) ?",8,"av","Exploitation","Audit","Le piège : pas d’agent = compromission facile. Agent mal réglé = backups cassés.", [
          opt("Oui (EDR/AV + exceptions + supervision) et ça n’impacte pas les jobs",8,["Exploitation","Sécurité"]),
          opt("Partiel (agent présent mais ‘au pif’ / incidents)",4,["Exploitation"],"Configurer whitelists/exclusions, monitorer l’impact, valider avec éditeur backup."),
          opt("Non",0,["Exploitation"],"Mettre un contrôle adapté (au minimum durcissement + monitoring), sinon la compromission est facile.")
        ]),
      ]
    },
    {
      id:"cat-audit-rest",
      title:"Audit — Restauration & preuves",
      subtitle:"tests réels, reprise applicative, runbooks",
      questions: [
        q("a11","Tests de restauration : vous restaurez réellement, avec preuves et temps mesuré ?",10,null,"Restauration","Audit","Un job OK n’est pas une restauration.", [
          opt("Oui (mensuel/trimestriel) + preuves",10,["Restauration"]),
          opt("Occasionnel",5,["Restauration"],"Planifier des restaurations régulières + conserver preuves (temps, succès)."),
          opt("Jamais / très rare",0,["Restauration"],"Faire des tests réels : sinon vous découvrirez trop tard.")
        ]),
        q("a12","Reprise applicative : test bout-en-bout (dépendances, auth, données) ?",8,null,"Restauration","Audit","Restaurer une base ne prouve pas que le service repart.", [
          opt("Oui, scénarios bout-en-bout",8,["Restauration"]),
          opt("Partiel (technique seulement)",4,["Restauration"],"Élargir les tests : dépendances, intégrations, secrets, DNS, certificats."),
          opt("Non",0,["Restauration"],"Tester la reprise applicative, pas juste la restauration technique.")
        ]),
      ]
    },
    {
      id:"cat-audit-ops",
      title:"Audit — Exploitation",
      subtitle:"alerting, dérives, capacité, fenêtres",
      questions: [
        q("a13","Supervision : alertes fiables sur échecs/dérives + traitement ?",8,null,"Exploitation","Audit","Une sauvegarde non surveillée se dégrade.", [
          opt("Oui (alerting + escalade + suivi)",8,["Exploitation"]),
          opt("Partiel (bruit/peu suivi)",4,["Exploitation"],"Fiabiliser alertes et instaurer une routine de traitement."),
          opt("Non",0,["Exploitation"],"Mettre alerting + routine : sinon ça va finir par casser.")
        ]),
        q("a14","Capacité : croissance et fenêtres de backup modélisées + seuils ?",6,null,"Design","Audit","Quand la capacité manque, on coupe la rétention (mauvais réflexe).", [
          opt("Oui (seuils + prévisions)",6,["Design","Exploitation"]),
          opt("Partiel",3,["Design"],"Modéliser croissance et ajouter des alertes de capacité."),
          opt("Non",0,["Design"],"Surveiller capacité/fenêtres : sinon perte de maîtrise.")
        ]),
      ]
    },
    {
      id:"cat-plan",
      title:"Cible — Design / planification",
      subtitle:"architecture, SaaS, tests prévus, conformité",
      questions: [
        q("b1","Architecture cible : modèle clair (on-prem/cloud/hybride) + RACI ?",6,null,"Design","Plan","Sans design, vous aurez du bricolage.", [
          opt("Oui (architecture + responsabilités)",6,["Design","Gouvernance"]),
          opt("Partiel",3,["Design"],"Formaliser architecture + RACI (qui restaure, qui valide)."),
          opt("Non",0,["Design"],"Définir l’architecture cible, sinon la solution arrive par hasard.")
        ]),
        q("b2","Immutabilité prévue (durées, exceptions, comptes séparés) ?",8,"immut","Sécurité","Plan","Si ce n’est pas dans le design, ça n’arrivera pas.", [
          opt("Oui",8,["Sécurité","Design"]),
          opt("En discussion",4,["Sécurité"],"Trancher et intégrer l’immutabilité au design."),
          opt("Non",0,["Sécurité"],"Ajouter immutabilité au design : sinon vous serez vulnérable.")
        ]),
        q("b3","Plan de tests futur : calendrier + scénarios + preuves + responsable ?",6,null,"Restauration","Plan","Un test sans responsable saute en premier.", [
          opt("Oui",6,["Restauration","Gouvernance"]),
          opt("Partiel",3,["Restauration"],"Définir plan de tests (scénarios, critères, ownership)."),
          opt("Non",0,["Restauration"],"Planifier les tests dès le design.")
        ]),
      ]
    },
  ];

  // --- Rendering ---
  function render(){
    const nav = $("#nav");
    nav.innerHTML = "";
    for (const cat of CATS){
      const btn = document.createElement("button");
      btn.className = "navbtn";
      btn.type = "button";
      btn.innerHTML = `
        <span>${escapeHtml(cat.title)}</span>
        <span class="navmeta">
          <span class="navhint" id="navhint-${cat.id}">—</span>
          <span class="check" id="navcheck-${cat.id}" aria-hidden="true">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none">
              <path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </span>
        </span>
      `;
      btn.addEventListener("click", () => {
        const el = document.getElementById(cat.id);
        if (!el) return;
        el.scrollIntoView({behavior:"smooth", block:"start"});
      });
      nav.appendChild(btn);
    }

    const cats = $("#cats");
    cats.innerHTML = "";
    for (const cat of CATS){
      const sec = document.createElement("section");
      sec.className = "cat";
      sec.id = cat.id;

      const hd = document.createElement("div");
      hd.className = "cat-hd";
      hd.innerHTML = `
        <div class="cat-title">
          <div class="t">${escapeHtml(cat.title)}</div>
          <div class="s">${escapeHtml(cat.subtitle)}</div>
        </div>
        <span class="pill" id="pill-${cat.id}">0/${cat.questions.length}</span>
      `;
      sec.appendChild(hd);

      const bd = document.createElement("div");
      bd.className = "cat-bd";

      for (const qu of cat.questions){
        bd.appendChild(renderQuestion(qu, cat.id));
      }

      sec.appendChild(bd);
      cats.appendChild(sec);
    }

    const allQ = CATS.flatMap(c => c.questions);
    $("#total").textContent = allQ.length;

    document.addEventListener("change", onAnyChange);
    onAnyChange();
    drawRadar(null);
  }

  function renderQuestion(qu, catId){
    const root = document.createElement("div");
    root.className = "q";
    root.id = `q-${qu.id}`;
    root.dataset.qid = qu.id;
    root.dataset.weight = qu.weight;
    root.dataset.axis = qu.axisKey;
    root.dataset.cat = catId;

    const info = qu.explainId ? `
      <span class="info" tabindex="0" role="button" aria-label="Explication" data-tip="${escapeHtml(qu.explainId)}">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none">
          <path d="M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20Z" stroke="currentColor" stroke-width="2"/>
          <path d="M12 17v-6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          <path d="M12 7h.01" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
      </span>
    ` : "";

    root.innerHTML = `
      <div class="qhead">
        <p class="qtitle">${escapeHtml(qu.title)}</p>
        <div class="qmeta">
          <span>${escapeHtml(qu.mode)} · ${qu.weight} pts</span>
          ${info}
        </div>
      </div>
    `;

    const opts = document.createElement("div");
    opts.className = "opts";

    qu.options.forEach((op, idx) => {
      const id = `${qu.id}_${idx}`;
      const lbl = document.createElement("label");
      lbl.className = "opt";
      lbl.setAttribute("for", id);
      lbl.innerHTML = `
        <input type="radio" name="${escapeHtml(qu.id)}" id="${escapeHtml(id)}"
          data-score="${op.score}"
          data-tags="${(op.tags||[]).join(",")}"
          data-priority="${escapeHtml(op.priority || "")}"
          data-extra="${escapeHtml(JSON.stringify(op.extra || null))}">
        <div>
          <div style="font-weight:850">${escapeHtml(op.label)}</div>
          <div class="mutedline">Score : ${op.score}/${qu.weight}</div>
        </div>
      `;
      opts.appendChild(lbl);
    });

    root.appendChild(opts);

    const hint = document.createElement("div");
    hint.className = "hint";
    hint.textContent = qu.hint;
    root.appendChild(hint);

    // 3-2-1 variants picker (scored) — only for a4
    if (qu.id === "a4"){
      const sub = document.createElement("div");
      sub.className = "bucket";
      sub.id = "sub_321";
      sub.style.display = "none";
      sub.innerHTML = `
        <div style="font-weight:1000;font-size:12px;margin-bottom:8px;">
          Variante(s) appliquée(s) (impacte le score de cette question)
        </div>
        <div class="small" style="margin-bottom:8px;color:var(--faint)">
          Choisissez ce qui est réellement en place. Si vous cochez <b>3-2-1-1-0</b>, vous devriez avoir des preuves de vérification/restauration.
        </div>
        <div style="display:flex;flex-direction:column;gap:8px" id="vlist"></div>
      `;
      const list = sub.querySelector("#vlist");
      for (const v of VARIANTS_321){
        const row = document.createElement("label");
        row.className = "opt";
        row.style.cursor = "pointer";
        row.innerHTML = `
          <input type="radio" name="v321" data-add="${v.add}" data-key="${escapeHtml(v.key)}">
          <div>
            <div style="font-weight:900">${escapeHtml(v.label)} <span class="mutedline">(+${v.add} pts)</span></div>
            <div class="mutedline">${escapeHtml(v.desc)}</div>
          </div>
        `;
        list.appendChild(row);
      }
      root.appendChild(sub);

      // Toggle show when base answer is "Oui"
      root.addEventListener("change", () => {
        const chosen = document.querySelector(`input[name="a4"]:checked`);
        const show = chosen && Number(chosen.dataset.score||0) >= 8;
        sub.style.display = show ? "block" : "none";
        if (!show){
          $$('input[name="v321"]').forEach(x => x.checked = false);
        }
      });
    }

    return root;
  }

  // --- Dynamic regroup: answered questions collapse & appear in left "completed" ---
  function onAnyChange(){
    updateAnsweredCount();
    updateCategoryProgress();
    rebuildCompletedPanel();
    applyCollapseAnswered();
  }

  function updateAnsweredCount(){
    const allQ = CATS.flatMap(c => c.questions);
    const answered = allQ.filter(q => document.querySelector(`input[name="${q.id}"]:checked`)).length;
    $("#answered").textContent = answered;
    const coverage = Math.round((answered / allQ.length) * 100);
    $("#coverage").textContent = coverage + "%";
    $("#answeredHint").textContent = `${answered} réponse(s)`;
  }

  function updateCategoryProgress(){
    for (const cat of CATS){
      const total = cat.questions.length;
      const ans = cat.questions.filter(q => document.querySelector(`input[name="${q.id}"]:checked`)).length;
      const pill = $(`#pill-${cat.id}`);
      if (pill) pill.textContent = `${ans}/${total}`;

      const hint = $(`#navhint-${cat.id}`);
      if (hint) hint.textContent = `${ans}/${total}`;

      const check = $(`#navcheck-${cat.id}`);
      if (check){
        check.classList.toggle("ok", ans === total && total > 0);
      }
    }
  }

  function applyCollapseAnswered(){
    const allQ = CATS.flatMap(c => c.questions);
    for (const q of allQ){
      const answered = !!document.querySelector(`input[name="${q.id}"]:checked`);
      const el = document.getElementById(`q-${q.id}`);
      if (!el) continue;
      // collapse by default when answered, unless "show all" mode enabled
      if (!window.__showAll){
        el.classList.toggle("done", answered);
      } else {
        el.classList.remove("done");
      }
    }
  }

  function rebuildCompletedPanel(){
    const panel = $("#completed");
    panel.innerHTML = "";

    // Group answered by category
    for (const cat of CATS){
      const answeredQs = cat.questions.filter(q => document.querySelector(`input[name="${q.id}"]:checked`));
      if (answeredQs.length === 0) continue;

      const det = document.createElement("details");
      det.open = false;

      det.innerHTML = `
        <summary>
          <span>${escapeHtml(cat.title)}</span>
          <span class="sum-meta">
            <span class="badgeMini">${answeredQs.length}/${cat.questions.length}</span>
          </span>
        </summary>
      `;

      for (const q of answeredQs){
        const chosen = document.querySelector(`input[name="${q.id}"]:checked`);
        const score = Number(chosen?.dataset.score || 0);
        const optIndex = Number((chosen?.id || "").split("_").pop());
        const optLabel = q.options[optIndex]?.label || "—";

        let extraLine = "";
        if (q.id === "a4"){
          const v = document.querySelector('input[name="v321"]:checked');
          if (v){
            const key = v.dataset.key;
            const add = Number(v.dataset.add||0);
            extraLine = `<div class="mutedline">Variante 3-2-1 : <b>${escapeHtml(key)}</b> (bonus +${add})</div>`;
          }
        }

        const item = document.createElement("div");
        item.className = "ansItem";
        item.innerHTML = `
          <div><b>${escapeHtml(q.title)}</b></div>
          <div class="mutedline">Réponse : ${escapeHtml(optLabel)} · Score ${score}/${q.weight}</div>
          ${extraLine}
          <div class="row">
            <button class="btnlink" data-edit="${escapeHtml(q.id)}">Modifier</button>
            <button class="btnlink danger" data-clear="${escapeHtml(q.id)}">Effacer</button>
          </div>
        `;
        det.appendChild(item);
      }

      panel.appendChild(det);
    }

    if (panel.children.length === 0){
      panel.innerHTML = `<div class="small" style="color:var(--faint)">Aucune réponse pour l’instant.</div>`;
    }

    // Bind edit/clear
    panel.querySelectorAll("[data-edit]").forEach(btn => {
      btn.addEventListener("click", (e) => {
        const id = e.currentTarget.dataset.edit;
        const el = document.getElementById(`q-${id}`);
        if (!el) return;
        // temporarily show this question and scroll to it
        window.__showAll = true;
        applyCollapseAnswered();
        el.scrollIntoView({behavior:"smooth", block:"center"});
        // highlight a bit
        el.style.outline = "2px solid rgba(138,180,255,.45)";
        setTimeout(()=> el.style.outline = "", 1200);
      });
    });

    panel.querySelectorAll("[data-clear]").forEach(btn => {
      btn.addEventListener("click", (e) => {
        const id = e.currentTarget.dataset.clear;
        // clear radios
        $$(`input[name="${id}"]`).forEach(r => r.checked = false);
        // clear variant if 3-2-1 question
        if (id === "a4") $$('input[name="v321"]').forEach(v => v.checked = false);
        onAnyChange();
      });
    });
  }

  // --- Score & Radar ---
  function compute(){
    const allQ = CATS.flatMap(c => c.questions);

    let raw = 0;
    let max = 0;
    const priorities = [];
    const tagsCount = new Map();
    const missing = [];

    const axisRaw = new Map(AXES.map(a => [a.key, 0]));
    const axisMax = new Map(AXES.map(a => [a.key, 0]));

    for (const q of allQ){
      max += q.weight;
      axisMax.set(q.axisKey, (axisMax.get(q.axisKey)||0) + q.weight);

      const chosen = document.querySelector(`input[name="${q.id}"]:checked`);
      if (!chosen){ missing.push(q); continue; }

      let sc = Number(chosen.dataset.score || 0);

      // Apply 3-2-1 variant scoring (a4 only) if base is "Oui"
      if (q.id === "a4" && sc >= 8){
        const v = document.querySelector('input[name="v321"]:checked');
        if (v){
          const add = Number(v.dataset.add || 0);
          sc = Math.min(q.weight, sc + add);
        }
      }

      raw += sc;
      axisRaw.set(q.axisKey, (axisRaw.get(q.axisKey)||0) + sc);

      const tags = (chosen.dataset.tags || "").split(",").map(s => s.trim()).filter(Boolean);
      for (const t of tags) tagsCount.set(t, (tagsCount.get(t)||0) + 1);

      if (sc <= (q.weight/2)){
        const pr = (chosen.dataset.priority || "").trim();
        if (pr) priorities.push(pr);
      }
    }

    const answered = allQ.length - missing.length;
    const coverage = answered / allQ.length;
    const normalized = max ? Math.round((raw / max) * 100 * (0.65 + 0.35 * coverage)) : 0;

    const level = getLevel(normalized, coverage);
    const insights = buildInsights(normalized, coverage, tagsCount, missing.length);

    updateUI(normalized, coverage, level, insights, priorities, tagsCount, missing);
    drawRadar(buildRadarValues(axisRaw, axisMax, coverage));

    return { normalized, raw, max, coverage, axisRaw:Object.fromEntries(axisRaw), axisMax:Object.fromEntries(axisMax) };
  }

  function getLevel(score, coverage){
    if (coverage < 0.7) return { text: "Incomplet → score peu fiable", badge: "warn" };
    if (score >= 85) return { text: "Solide (mais prouve-le)", badge: "ok" };
    if (score >= 70) return { text: "Correct (mais fragile)", badge: "warn" };
    if (score >= 50) return { text: "Fragile (ça casse sous stress)", badge: "bad" };
    return { text: "Critique (fausse sécurité)", badge: "bad" };
  }

  function buildInsights(score, coverage, tagsCount, missingCount){
    const topTags = [...tagsCount.entries()].sort((a,b)=>b[1]-a[1]).slice(0,3).map(([t])=>t);
    const lines = [];

    if (missingCount) lines.push(`Il manque ${missingCount} réponse(s). Donc oui : le score est approximatif.`);
    if (coverage < 0.7) lines.push("Couverture faible : vous laissez des angles morts. Ceux-là mordent en incident.");

    if (score >= 85) lines.push("Bien. Maintenant : avez-vous des preuves de restauration en conditions dégradées ?");
    else if (score >= 70) lines.push("Base correcte, mais le ransomware vise AD puis backup. Votre design casse-t-il cette chaîne ?");
    else if (score >= 50) lines.push("Vous avez des backups, pas forcément une reprise fiable. Les tests et l’immutabilité sont vos dettes.");
    else lines.push("Arrêtez de vous rassurer : immutabilité + séparation + tests réels. Sinon c’est du décor.");

    if (topTags.length) lines.push(`Thèmes dominants : ${topTags.join(", ")}. Êtes-vous sûr que c’est “maîtrisé” ?`);
    return lines;
  }

  function updateUI(score, coverage, level, insights, priorities, tagsCount, missing){
    $("#score").textContent = score;
    $("#barFill").style.width = Math.max(0, Math.min(100, score)) + "%";
    $("#levelText").textContent = level.text;

    const badge = $("#badge");
    badge.className = "badge " + level.badge;
    badge.textContent = level.badge === "ok" ? "OK" : (level.badge === "warn" ? "À renforcer" : "Risque");

    $("#coverage").textContent = Math.round(coverage * 100) + "%";

    const ul = $("#insights");
    ul.innerHTML = "";
    insights.forEach(t => {
      const li = document.createElement("li");
      li.textContent = t;
      ul.appendChild(li);
    });

    const tags = $("#tags");
    tags.innerHTML = "";
    const sortedTags = [...tagsCount.entries()].sort((a,b)=>b[1]-a[1]).slice(0,8);
    if (sortedTags.length){
      for (const [t,c] of sortedTags){
        const span = document.createElement("span");
        span.className = "tag";
        span.textContent = `${t} · ${c}`;
        tags.appendChild(span);
      }
    } else {
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = "—";
      tags.appendChild(span);
    }

    const pr = $("#priorities");
    pr.innerHTML = "";
    const uniq = [...new Set(priorities)].slice(0, 12);
    if (uniq.length){
      uniq.forEach(p => {
        const li = document.createElement("li");
        li.textContent = p;
        pr.appendChild(li);
      });
    } else {
      const li = document.createElement("li");
      li.textContent = missing.length ? "Répondez aux questions restantes pour faire ressortir des priorités." : "Pas d’urgence détectée… ou bien vous avez bien répondu.";
      pr.appendChild(li);
    }

    showToast(score, coverage, level);
  }

  function showToast(score, coverage, level){
    const t = $("#toast");
    $("#toastScore").textContent = score + "/100";
    const cov = Math.round(coverage * 100);
    $("#toastHint").textContent = `· Couverture ${cov}% · ${level.text}`;
    t.classList.add("show");
    clearTimeout(showToast._to);
    showToast._to = setTimeout(()=> t.classList.remove("show"), 2600);
  }

  function buildRadarValues(axisRaw, axisMax, coverage){
    const values = AXES.map(a => {
      const mx = axisMax.get(a.key) || 0;
      const rw = axisRaw.get(a.key) || 0;
      return mx ? (rw/mx) : 0;
    });
    return { values, coverage };
  }

  function drawRadar(data){
    const canvas = $("#radar");
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    const cx = Math.floor(w/2), cy = Math.floor(h/2)+8;
    const r = Math.min(w,h) * 0.34;

    // Grid
    const levels = 5;
    for (let i=1;i<=levels;i++){
      const rr = r * (i/levels);
      ctx.beginPath();
      ctx.arc(cx,cy,rr,0,Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,0.09)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    const n = AXES.length;
    for (let i=0;i<n;i++){
      const ang = (Math.PI*2 * i / n) - Math.PI/2;
      const x = cx + Math.cos(ang)*r;
      const y = cy + Math.sin(ang)*r;

      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.lineTo(x,y);
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      ctx.stroke();

      const lx = cx + Math.cos(ang)*(r+20);
      const ly = cy + Math.sin(ang)*(r+20);

      ctx.font = "12px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(232,237,247,0.92)";
      ctx.textAlign = (Math.cos(ang) > 0.25) ? "left" : (Math.cos(ang) < -0.25 ? "right" : "center");
      ctx.textBaseline = (Math.sin(ang) > 0.25) ? "top" : (Math.sin(ang) < -0.25 ? "bottom" : "middle");
      ctx.fillText(AXES[i].label, lx, ly);
    }

    if (!data){
      $("#radarHint").textContent = "Répondez puis calculez : la toile affichera vos creux (angles morts).";
      return;
    }
    const cov = Math.round((data.coverage||0)*100);
    $("#radarHint").textContent = cov < 70
      ? `Couverture ${cov}% : toile indicative.`
      : `Couverture ${cov}% : toile basée sur vos réponses.`;

    const vals = data.values;

    // Polygon
    ctx.beginPath();
    for (let i=0;i<n;i++){
      const ang = (Math.PI*2 * i / n) - Math.PI/2;
      const rr = r * Math.max(0, Math.min(1, vals[i]));
      const x = cx + Math.cos(ang)*rr;
      const y = cy + Math.sin(ang)*rr;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle = "rgba(138,180,255,0.18)";
    ctx.strokeStyle = "rgba(138,180,255,0.75)";
    ctx.lineWidth = 2;
    ctx.fill();
    ctx.stroke();

    // Points
    for (let i=0;i<n;i++){
      const ang = (Math.PI*2 * i / n) - Math.PI/2;
      const rr = r * Math.max(0, Math.min(1, vals[i]));
      const x = cx + Math.cos(ang)*rr;
      const y = cy + Math.sin(ang)*rr;
      ctx.beginPath();
      ctx.arc(x,y,4,0,Math.PI*2);
      ctx.fillStyle = "rgba(49,208,170,0.85)";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }

  // --- Export / Reset ---
  function exportSummary(){
    const result = compute();
    const allQ = CATS.flatMap(c => c.questions);

    const answers = {};
    for (const q of allQ){
      const chosen = document.querySelector(`input[name="${q.id}"]:checked`);
      if (!chosen){ answers[q.id] = null; continue; }
      const optIndex = Number((chosen.id || "").split("_").pop());
      let score = Number(chosen.dataset.score||0);

      // apply variant again for export
      let v321 = null;
      if (q.id === "a4" && score >= 8){
        const v = document.querySelector('input[name="v321"]:checked');
        if (v){
          const add = Number(v.dataset.add||0);
          const key = v.dataset.key;
          score = Math.min(q.weight, score + add);
          v321 = { key, add };
        }
      }

      answers[q.id] = {
        mode: q.mode,
        axis: q.axisKey,
        weight: q.weight,
        score,
        option: q.options[optIndex]?.label || "—",
        variant_321: v321
      };
    }

    const axisScores = {};
    for (const a of AXES){
      const raw = result.axisRaw[a.key] ?? 0;
      const mx  = result.axisMax[a.key] ?? 0;
      axisScores[a.key] = mx ? Math.round((raw/mx)*100) : 0;
    }

    const payload = {
      generated_at: new Date().toISOString(),
      score_total: result.normalized,
      coverage: result.coverage,
      radar: axisScores,
      answers
    };

    const text = JSON.stringify(payload, null, 2);
    navigator.clipboard?.writeText(text).then(()=>{
      showToast(result.normalized, result.coverage, {text:"Compte-rendu copié", badge:"ok"});
    }).catch(()=>{
      window.prompt("Copiez le JSON :", text);
    });
  }

  function resetAll(){
    $$('input[type="radio"]').forEach(i => i.checked = false);
    $$('input[name="v321"]').forEach(i => i.checked = false);
    window.__showAll = false;
    $("#score").textContent = "—";
    $("#barFill").style.width = "0%";
    $("#levelText").textContent = "—";
    const badge = $("#badge");
    badge.className = "badge bad";
    badge.textContent = "—";
    $("#tags").innerHTML = "";
    $("#priorities").innerHTML = "<li>—</li>";
    drawRadar(null);
    onAnyChange();
  }

  // --- Tooltip logic ---
  const tip = $("#tip");
  const tipTitle = $("#tipTitle");
  const tipText = $("#tipText");
  const tipExtra = $("#tipExtra");

  function showTip(explainId, anchorRect){
    const g = GLOSSARY[explainId];
    if (!g) return;

    tipTitle.textContent = g.title;
    tipText.textContent = g.text;

    if (g.extra){
      tipExtra.style.display = "block";
      tipExtra.innerHTML = g.extra;
    } else {
      tipExtra.style.display = "none";
      tipExtra.innerHTML = "";
    }

    tip.classList.add("show");
    tip.setAttribute("aria-hidden","false");

    const margin = 12;
    const w = tip.offsetWidth;
    const h = tip.offsetHeight;

    let left = anchorRect.left + (anchorRect.width/2) - (w/2);
    let top  = anchorRect.top - h - 10;

    const vw = window.innerWidth;
    const vh = window.innerHeight;

    if (left < margin) left = margin;
    if (left + w > vw - margin) left = vw - margin - w;

    if (top < margin){
      top = anchorRect.bottom + 10;
      if (top + h > vh - margin) top = Math.max(margin, vh - margin - h);
    }

    tip.style.left = left + "px";
    tip.style.top  = top + "px";
  }

  function hideTip(){
    tip.classList.remove("show");
    tip.setAttribute("aria-hidden","true");
  }

  function attachTooltipHandlers(){
    document.addEventListener("mouseover", (e) => {
      const t = e.target.closest?.(".info[data-tip]");
      if (!t) return;
      const id = t.dataset.tip;
      showTip(id, t.getBoundingClientRect());
    });
    document.addEventListener("mouseout", (e) => {
      const t = e.target.closest?.(".info[data-tip]");
      if (!t) return;
      const related = e.relatedTarget;
      if (related && (related === tip || tip.contains(related))) return;
      hideTip();
    });
    document.addEventListener("click", (e) => {
      const info = e.target.closest?.(".info[data-tip]");
      if (info){
        const id = info.dataset.tip;
        // toggle if same
        const isSame = tip.classList.contains("show") && tipTitle.textContent === (GLOSSARY[id]?.title || "");
        if (isSame) { hideTip(); return; }
        showTip(id, info.getBoundingClientRect());
        return;
      }
      if (tip.classList.contains("show") && !tip.contains(e.target)) hideTip();
    });
    tip.addEventListener("mouseleave", hideTip);
    $("#tipClose").addEventListener("click", hideTip);
    document.addEventListener("keydown", (e)=>{ if (e.key === "Escape") hideTip(); });
  }

  // --- Buttons ---
  $("#btnScore").addEventListener("click", compute);
  $("#btnExport").addEventListener("click", exportSummary);
  $("#btnReset").addEventListener("click", resetAll);
  $("#openAll").addEventListener("click", () => {
    // open all answered details
    $$("#completed details").forEach(d => d.open = true);
  });
  $("#closeAll").addEventListener("click", () => {
    $$("#completed details").forEach(d => d.open = false);
  });
  $("#showAllQs").addEventListener("click", () => {
    window.__showAll = !window.__showAll;
    $("#showAllQs").textContent = window.__showAll ? "Masquer les questions répondues" : "Afficher toutes les questions";
    applyCollapseAnswered();
  });

  // Init
  render();
  attachTooltipHandlers();
</script>
</body>
</html>
