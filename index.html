<!doctype html>
<html lang="fr">
<head>
 <meta charset="utf-8" />
 <meta name="viewport" content="width=device-width,initial-scale=1" />
 <title>CIDR_Normand</title>
 <style>
 :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa6b2;--accent:#60a5fa;--ok:#34d399;--danger:#fb7185}
 body{font-family:Inter,Segoe UI,system-ui,Arial;background:#081226;color:#e6eef6;margin:0;padding:16px}
 /* Header */
 .app-title{display:flex;align-items:center;gap:10px;font-size:18px;margin:0}
 .app-title svg{width:36px;height:36px;flex:0036px}
 .app-title span{font-weight:600}
 /* Logo tweaks */
 #logoImg{width:36px;height:36px;object-fit:contain;display:block;background:transparent;filter:invert(1);mix-blend-mode:screen}
 .app-title{align-items:center}
 /* Layout */
 .app{display:grid;grid-template-columns:minmax(260px,360px)1fr;gap:12px;align-items:start}
 .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:12px;border-radius:8px;box-shadow:02px8px rgba(2,6,23,0.6)}
 .left{width:auto;position:sticky;top:12px;max-height:calc(100vh -24px);overflow:auto;resize:horizontal;min-width:260px}
 .right{min-width:0}
 label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
 input,select,textarea{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
 button{margin-top:8px;padding:8px10px;border-radius:6px;border:0;background:var(--accent);color:#05263b;cursor:pointer}
 .site-item{padding:8px;border-radius:6px;margin-bottom:6px;cursor:pointer}
 .site-item.selected{background:rgba(96,165,250,0.12)}
 table{width:100%;border-collapse:collapse;margin-top:12px}
 th,td{padding:6px;text-align:left;border-bottom:1px solid rgba(255,255,255,0.03);font-size:13px}
 thead th{position:sticky;top:0;background:var(--card);z-index:2}
 tbody tr:hover{background:rgba(255,255,255,0.02)}
 .mini{font-size:12px;color:var(--muted)}
 .bar-wrap{height:60px;background:#071024;border-radius:6px;padding:8px;margin-top:8px}
 .bar{height:28px;border-radius:4px;position:relative;overflow:hidden}
 .seg{position:absolute;top:0;bottom:0}
 .seg.free{background:linear-gradient(90deg,#0f1724,rgba(255,255,255,0.02));border:1px dashed rgba(255,255,255,0.03)}
 .seg.used{background:linear-gradient(90deg,#2563eb,#06b6d4);opacity:0.95}
 .seg .label{position:absolute;left:4px;top:2px;font-size:11px;color:#fff;text-shadow:01px0 rgba(0,0,0,0.6);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:90%}
 .external-label{position:absolute;top:34px;font-size:11px;color:var(--muted);pointer-events:none;white-space:nowrap;transform:translateX(-50%)}
 #barTooltip{position:fixed;display:none;padding:6px8px;background:rgba(2,6,23,0.95);color:#fff;border-radius:6px;font-size:12px;z-index:1000;box-shadow:06px18px rgba(2,6,23,0.6)}
 .controls{display:flex;gap:8px;align-items:center}
 .note{font-size:12px;color:var(--muted);margin-top:6px}
 #debug{color:#fecaca;background:#2b1120;padding:6px;border-radius:6px;margin-top:8px;font-size:13px;display:none}
 /* Sections */
 .section{border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:12px;margin-top:12px;background:rgba(255,255,255,0.02)}
 .section:first-child{margin-top:0}
 .section-title{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.06em;margin:008px0;display:flex;align-items:center;gap:6px}
 .section-title::before{content:'';display:inline-block;width:6px;height:6px;border-radius:50%;background:var(--accent);opacity:.7}
 /* Right content columns */
 #siteArea{display:grid;grid-template-columns:1fr1fr;gap:12px;align-items:start}
 .visual-section{display:grid;grid-template-columns:minmax(280px,1fr)1.3fr;gap:12px}
 .visual-section .section-title{grid-column:1 / -1}
 #allocTableContainer{max-height:50vh;overflow:auto}
 /* Responsive */
 @media (max-width:1100px){
 .app{grid-template-columns:1fr}
 .left{position:static;max-height:none;resize:none}
 #siteArea{grid-template-columns:1fr}
 .visual-section{grid-template-columns:1fr}
 }
 </style>
</head>
<body>
 <h1 class="app-title">
 <img id="logoImg" src="cidr-manager.png" alt="Logo" />
 <span>CIDR_Normand_v1</span>
 </h1>
 <div class="app">
 <div class="panel left">
 <div class="section">
 <div class="section-title">Sites</div>
 <div id="sitesList" style="margin-top:8px"></div>
 </div>

 <div class="section">
 <div class="section-title">Ajouter un site</div>
 <label>Ajouter site (nom)</label>
 <input id="siteName" placeholder="Nom du site (ex: PARIS)" />
 <label>Root CIDR</label>
 <input id="siteCidr" placeholder="10.0.0.0/16" />
 <button id="addSiteBtn">Ajouter site</button>
 </div>

 <div class="section">
 <div class="section-title">Import / Export</div>
 <div style="display:flex;gap:8px;flex-wrap:wrap">
 <button id="importBtn" style="background:#f59e0b">Importer JSON</button>
 <button id="exportBtn" style="background:#10b981">Exporter JSON</button>
 <button id="loadLocalBtn" style="background:#3b82f6">Charger JSON local</button>
 </div>
 <input id="fileInput" type="file" style="display:none" accept="application/json" />
 </div>
 </div>

 <div class="panel right">
 <div id="siteArea">
 <div class="section">
 <div class="section-title">Ajout VLAN & Ajout en masse</div>
 <div id="debug"></div>
 <div class="mini" id="siteHeader">Sélectionnez un site</div>
 <div id="siteControls" style="display:none">
 <div style="display:flex;gap:8px;align-items:center">
 <div style="flex:1">
 <label>Nouvelle allocation (CIDR)</label>
 <input id="allocCidr" placeholder="ex:10.0.1.0/24" />
 </div>
 <div style="width:140px">
 <label>VLAN</label>
 <input id="allocVlan" placeholder="100" />
 </div>
 </div>
 <label>Description</label>
 <input id="allocDesc" placeholder="But ou propriétaire" />
 <div class="controls">
 <button id="addAllocBtn">Ajouter allocation</button>
 <button id="suggestBtn" style="background:#64748b">Suggérer next /24</button>
 </div>
 </div>

 <!-- Bulk paste area -->
 <div style="margin-top:8px">
 <label>Ajouter en masse (coller depuis Excel: VLAN, Nom, Réseau, Masque)</label>
 <textarea id="bulkInput" placeholder="VLANID	VLAN	SUBNET	MASK" style="width:100%;height:90px;padding:8px;border-radius:6px;background:transparent;color:inherit;border:1px solid rgba(255,255,255,0.04);"></textarea>
 <div class="controls"><button id="bulkAddBtn" style="background:#10b981">Ajouter en masse</button></div>
 </div>

 <div class="note">Export/Import sauvegarde aussi les allocations. Les changements sont auto-sauvegardés dans localStorage.</div>
 </div>

 <div class="section visual-section">
 <div class="section-title">Représentation visuelle & Tableau</div>
 <div id="visual" style="margin-top:4px">
 <div class="bar-wrap"><div id="bar" class="bar"></div></div>
 <div id="freeList" class="mini" style="margin-top:8px"></div>
 <div style="margin-top:8px">
 <button id="calcFreeBtn" style="background:#6366f1">Calculer subnets dispo</button>
 <div id="suggestedList" class="mini" style="margin-top:8px"></div>
 </div>
 </div>

 <div id="allocTableContainer">
 <table id="allocTable">
 <thead><tr><th>VLAN ID</th><th>VLAN NAME</th><th>CIDR</th><th>Masque</th><th>IPs</th><th>1st</th><th>last</th><th></th></tr></thead>
 <tbody></tbody>
 </table>
 </div>
 </div> <!-- end .section.visual-section -->
 </div> <!-- end #siteArea -->
 </div> <!-- end .panel.right -->
 </div> <!-- end .app -->

<script>
// Utilities
function ipToInt(ip){return ip.split('.').reduce((acc,p)=>acc*256+parseInt(p,10),0)>>>0}
function intToIp(i){return [(i>>>24)&255,(i>>>16)&255,(i>>>8)&255,i&255].join('.')}
function parseCidr(cidr){if(typeof cidr !== 'string') throw new Error('Invalid CIDR'); const parts=cidr.split('/'); if(parts.length!==2) throw new Error('Invalid CIDR'); const addr=parts[0]; const prefix=parseInt(parts[1],10); if(isNaN(prefix)||prefix<0||prefix>32) throw new Error('Invalid prefix'); const ip=ipToInt(addr); const mask = prefix===0?0:((0xffffffff<< (32-prefix))>>>0); const network = ip & mask; const broadcast = network | (~mask >>>0); return {network,broadcast,prefix,mask:mask>>>0}; }

// Accept input like "10.0.1.0/24" or "10.0.1.0255.255.255.0" or "10.0.1.0/255.255.255.0"
function dottedMaskToPrefix(maskStr){
 if(!maskStr || maskStr.indexOf('.')===-1) throw new Error('Invalid mask');
 const m = ipToInt(maskStr);
 // compute number of leading ones
 let cnt =0; for(let i=31;i>=0;i--){ if((m>>>i &1)===1) cnt++; else break; }
 // verify mask is contiguous: rebuild mask from cnt and compare
 const rebuilt = cnt===0?0:((0xffffffff<< (32-cnt))>>>0);
 if(rebuilt !== m) throw new Error('Non-contiguous mask');
 return cnt;
}

function normalizeCidr(input){
 // trim and normalize whitespace
 input = (input||'').trim();
 if(input.indexOf('/')!==-1){
 // could be /24 or /255.255.255.0
 const parts = input.split('/');
 if(parts.length!==2) throw new Error('Invalid CIDR');
 const addr = parts[0].trim();
 const suffix = parts[1].trim();
 if(suffix.indexOf('.')!==-1){
 const p = dottedMaskToPrefix(suffix);
 return addr + '/' + p;
 }
 // numeric prefix
 return addr + '/' + parseInt(suffix,10);
 }
 // try space separated address and mask
 const sp = input.split(/\s+/);
 if(sp.length===2){
 const addr = sp[0].trim();
 const mask = sp[1].trim();
 if(mask.indexOf('.')!==-1){
 const p = dottedMaskToPrefix(mask);
 return addr + '/' + p;
 }
 // if second token is numeric prefix
 return addr + '/' + parseInt(mask,10);
 }
 throw new Error('Format non supporté');
}

// Convert a numeric range [start,end] into a list of largest possible aligned CIDRs
function rangeToCidrs(start, end){
 const res = [];
 let cur = start;
 while (cur <= end) {
 // choose the largest block (smallest prefix) aligned at cur and fitting in [cur,end]
 let chosenPrefix = null;
 for (let p =0; p <=31; p++) { // /31 is the smallest we propose (no /32 suggestions)
 const blockSize = Math.pow(2,32 - p);
 const mask = p ===0 ?0 : ((0xffffffff << (32 - p)) >>>0);
 const network = cur & mask;
 if (network !== cur) continue; // not aligned
 if (cur + blockSize -1 > end) continue; // doesn't fit
 chosenPrefix = p; // first (smallest p) is largest block
 break;
 }
 if (chosenPrefix === null) {
 // nothing aligned for prefixes up to /31, fall back to smallest acceptable /31 if it fits
 if (cur +1 <= end) {
 res.push(intToIp(cur) + '/31');
 cur +=2;
 continue;
 }
 // no space left
 break;
 }
 res.push(intToIp(cur) + '/' + chosenPrefix);
 cur += Math.pow(2,32 - chosenPrefix);
 }
 return res;
}

// Calculate usable IP range for a CIDR
function cidrRange(cidr){
 const {network, broadcast, prefix} = parseCidr(cidr);
 // For /31 and /32, all IPs are usable
 if(prefix >=31){
 return {usableFirst: network, usableLast: broadcast};
 }
 // For others, exclude network and broadcast
 return {usableFirst: network +1, usableLast: broadcast -1};
}

// Format IP count from prefix length
function formatCount(prefix){
 const total = Math.pow(2,32 - prefix);
 if(prefix >=31) return total + ' IPs';
 const usable = total -2;
 return usable + ' IPs';
}

// Calculate host count for prefix (used in suggestBtn)
function hostsCount(prefix){
 return Math.pow(2,32 - prefix);
}

// Storage
const STORAGE_KEY='cidr_normand_v1'; let state={sites:[]};
function load(){ try{ const raw=localStorage.getItem(STORAGE_KEY); if(raw) state=JSON.parse(raw); else state={sites:[]}; }catch(e){ state={sites:[]}; } }
function save(){ localStorage.setItem(STORAGE_KEY,JSON.stringify(state)); renderSites(); if(typeof writeFileIfHandle === 'function'){ try{ writeFileIfHandle(); }catch(e){ console.warn('writeFileIfHandle failed',e); } } }
if(typeof writeFileIfHandle !== 'function'){ function writeFileIfHandle(){ /* no-op */ } }
// helpers
function uid(){return Math.random().toString(36).slice(2,9)}
function findSite(id){ return state.sites.find(s=>s.id===id); }
function rangesFromCidr(cidr){ const p=parseCidr(cidr); return [{start:p.network,end:p.broadcast}]; }
function allocsToRanges(allocs){ return (allocs||[]).map(a=>{ const r=parseCidr(a.cidr); return {start:r.network,end:r.broadcast,cidr:a.cidr,description:a.description || '',vlan:a.vlan}; }).sort((x,y)=>x.start-y.start); }
function subtractRanges(baseRanges,occupiedRanges){ let free=[]; for(const b of baseRanges){ let segments=[{start:b.start,end:b.end}]; for(const o of occupiedRanges){ segments = segments.flatMap(seg=>{ if(o.end < seg.start || o.start > seg.end) return [seg]; const parts=[]; if(o.start>seg.start) parts.push({start:seg.start,end:o.start-1}); if(o.end<seg.end) parts.push({start:o.end+1,end:seg.end}); return parts; }); } free.push(...segments); } return free; }

// UI
let selectedSiteId=null;
function renderSites(){
 const el = document.getElementById('sitesList');
 el.innerHTML = '';
 state.sites.forEach(s => {
 const wrap = document.createElement('div');
 wrap.className = 'site-item' + (s.id === selectedSiteId ? ' selected' : '');
 wrap.style.position = 'relative';
 wrap.style.padding = '8px';
 wrap.style.borderRadius = '6px';
 wrap.style.marginBottom = '6px';
 wrap.style.cursor = 'pointer';
 wrap.setAttribute('role','button');
 wrap.tabIndex =0;

 const label = document.createElement('span');
 label.textContent = s.name + ' — ' + s.rootCidr;
 label.style.userSelect = 'none';
 wrap.appendChild(label);

 const delBtn = document.createElement('button');
 delBtn.type = 'button';
 delBtn.textContent = '✖';
 delBtn.title = 'Supprimer le site';
 delBtn.style.cssText = 'position:absolute;right:6px;top:6px;background:#ef4444;border:0;color:#fff;padding:4px6px;border-radius:4px;cursor:pointer';
 delBtn.addEventListener('click', (ev) => {
 ev.stopPropagation();
 if(!confirm('Supprimer le site "'+s.name+'" et toutes ses allocations ?')) return;
 state.sites = state.sites.filter(x => x.id !== s.id);
 if(selectedSiteId === s.id) selectedSiteId = null;
 save(); renderSite(); renderSites();
 });
 wrap.appendChild(delBtn);

 wrap.addEventListener('click', () => { selectedSiteId = s.id; renderSite(); renderSites(); });
 wrap.addEventListener('keydown', (e) => { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); wrap.click(); } });

 el.appendChild(wrap);
 });
}

function renderSite(){
 const header=document.getElementById('siteHeader');
 const controls=document.getElementById('siteControls');
 if(!selectedSiteId){ header.textContent='Sélectionnez un site'; controls.style.display='none'; return; }
 const site=findSite(selectedSiteId); if(!site){ header.textContent='Site introuvable'; controls.style.display='none'; return; }
 header.textContent=site.name+' — '+site.rootCidr; controls.style.display='block';
 // allocations table
 const tbody=document.querySelector('#allocTable tbody');
 tbody.innerHTML='';
 (site.allocations||[]).forEach(a=>{
 const p = parseCidr(a.cidr); const r=cidrRange(a.cidr); const tr=document.createElement('tr');
 tr.innerHTML=`<td>${a.vlan||''}</td><td>${a.description||''}</td><td>${a.cidr}</td><td>${intToIp(p.mask)}</td><td class="mini">${formatCount(p.prefix)}</td><td>${r.usableFirst?intToIp(r.usableFirst):'n/a'}</td><td>${r.usableLast?intToIp(r.usableLast):'n/a'}</td><td><button class="delBtn" data-cidr="${a.cidr}" style="background:#ef4444">x</button></td>`;
 tbody.appendChild(tr);
 });
 Array.from(document.querySelectorAll('.delBtn')).forEach(b=>b.onclick=()=>{ const cidr=b.getAttribute('data-cidr'); if(!confirm('Supprimer '+cidr+' ?')) return; site.allocations=site.allocations.filter(x=>x.cidr!==cidr); save(); renderSite(); });
 // visualization
 const base=rangesFromCidr(site.rootCidr)[0]; const occupied=allocsToRanges(site.allocations||[]); const free=subtractRanges([base],occupied);
 renderBar(base,occupied,free);
 const freeList=document.getElementById('freeList'); freeList.innerHTML='Libre: '+free.map(f=>intToIp(f.start)+' - '+intToIp(f.end)+' ('+(f.end-f.start+1)+' IPs)').join(' | ');
 // suggestions
 const suggestedList = document.getElementById('suggestedList'); suggestedList.innerHTML=''; let total=0;
 free.forEach(f=>{ const cidrs = rangeToCidrs(f.start,f.end); cidrs.forEach(c=>{ total++; const div = document.createElement('div'); div.style.cursor='pointer'; div.style.padding='4px'; div.style.borderBottom='1px solid rgba(255,255,255,0.03)'; const prefix = parseInt(c.split('/')[1],10); div.textContent = c + ' — ' + formatCount(prefix); div.title = 'Cliquer pour remplir le champ d\'allocation'; div.onclick = ()=>{ document.getElementById('allocCidr').value = c; document.getElementById('allocCidr').focus(); }; suggestedList.appendChild(div); }); });
 if(total===0) suggestedList.textContent = 'Aucun subnet libre trouvé';
}

function renderBar(base,occupied,free){
 const bar=document.getElementById('bar'); bar.innerHTML=''; bar.style.position='relative';
 const span=base.end-base.start+1; const rect = bar.getBoundingClientRect();
 const w = Math.max(200, Math.floor(rect.width||bar.clientWidth||bar.parentElement.clientWidth||600));
 const scale=(i)=> Math.max(2, Math.round((i-base.start)/span*w));
 // free
 free.forEach(f=>{ const left=scale(f.start); const right=scale(f.end+1); const width=Math.max(2,right-left); const seg=document.createElement('div'); seg.className='seg free'; seg.style.left=(left/w*100)+'%'; seg.style.width=(width/w*100)+'%'; seg.title='Libre: '+intToIp(f.start)+' - '+intToIp(f.end)+' ('+(f.end-f.start+1)+' IPs)'; bar.appendChild(seg); });
 // tooltip
 let tooltip = document.getElementById('barTooltip'); if(!tooltip){ tooltip = document.createElement('div'); tooltip.id = 'barTooltip'; document.body.appendChild(tooltip); }
 Array.from(bar.querySelectorAll('.external-label')).forEach(n=>n.remove());
 // used
 occupied.forEach((o)=>{ const left=scale(o.start); const right=scale(o.end+1); const width=Math.max(2,right-left); const seg=document.createElement('div'); seg.className='seg used'; seg.style.left=(left/w*100)+'%'; seg.style.width=(width/w*100)+'%'; const titleText = (o.description?o.description+' - ':'')+intToIp(o.start)+' - '+intToIp(o.end); seg.title = titleText; const lbl=document.createElement('div'); lbl.className='label'; lbl.textContent=(o.description && o.description.length>0)? o.description : o.cidr; const pct = (width / w *100); if(pct >=6){ seg.appendChild(lbl); } else { const marker = document.createElement('div'); marker.style.position='absolute'; marker.style.left='50%'; marker.style.top='0'; marker.style.transform='translateX(-50%)'; marker.style.width='6px'; marker.style.height='100%'; marker.style.background='rgba(255,255,255,0.12)'; marker.style.borderRadius='2px'; seg.appendChild(marker); const ext = document.createElement('div'); ext.className='external-label'; ext.style.left = (left/w*100 + (width/w*50)) + '%'; ext.textContent = (o.description && o.description.length>0)? o.description : o.cidr; bar.appendChild(ext); }
 seg.addEventListener('mouseenter', ()=>{ tooltip.style.display='block'; tooltip.textContent = titleText; });
 seg.addEventListener('mousemove', (e)=>{ tooltip.style.left = (e.clientX +12) + 'px'; tooltip.style.top = (e.clientY +12) + 'px'; });
 seg.addEventListener('mouseleave', ()=>{ tooltip.style.display='none'; });
 bar.appendChild(seg);
 });
}

function bindEvents(){
 try{
 document.getElementById('addSiteBtn').addEventListener('click',()=>{
 const name=document.getElementById('siteName').value.trim(); const cidr=document.getElementById('siteCidr').value.trim(); if(!name||!cidr){ alert('Nom et CIDR requis'); return; }
 try{ parseCidr(cidr); }catch(e){ alert('CIDR invalide'); return; }
 const newSite={id:uid(),name:name,rootCidr:cidr,allocations:[]}; state.sites.push(newSite); save(); selectedSiteId=newSite.id; renderSites(); renderSite();
 });

 document.getElementById('addAllocBtn').addEventListener('click',()=>{
 const raw=document.getElementById('allocCidr').value.trim(); const vlan=document.getElementById('allocVlan').value.trim(); const desc=document.getElementById('allocDesc').value.trim(); if(!raw){ alert('CIDR requis'); return; }
 let cidr; try{ cidr = normalizeCidr(raw); parseCidr(cidr); }catch(e){ alert('CIDR invalide: '+(e && e.message?e.message:e)); return; }
 const site=findSite(selectedSiteId); if(!site){ alert('Sélectionnez un site'); return; }
 const root=parseCidr(site.rootCidr); const a=parseCidr(cidr);
 if(a.network < root.network || a.broadcast > root.broadcast){ alert('Hors du root'); return; }
 const overlap=site.allocations.some(x=>{ const r=parseCidr(x.cidr); return !(a.broadcast<r.network || a.network>r.broadcast); });
 if(overlap){ alert('Chevauchement'); return; }
 site.allocations.push({cidr:cidr,vlan:vlan||null,description:desc,created:new Date().toISOString()}); save(); renderSite();
 });

 document.getElementById('suggestBtn').addEventListener('click',()=>{ const site=findSite(selectedSiteId); if(!site){ alert('Sélectionnez un site'); return; }
 const pref=prompt('Prefix désiré (ex:24)','24'); if(!pref) return; const p=parseInt(pref,10); if(isNaN(p)||p<1||p>32){ alert('Prefix invalide'); return; }
 const base=rangesFromCidr(site.rootCidr)[0]; const occupied=allocsToRanges(site.allocations||[]); const free=subtractRanges([base],occupied);
 const size=hostsCount(p);
 for(const f of free){ let candidate = Math.ceil(f.start/size)*size; while(candidate+size-1<=f.end){ const cidrStr=intToIp(candidate) + '/' + p; if(site.allocations.some(a=>a.cidr===cidrStr)){ candidate += size; continue; }
 const descr=prompt('Description pour '+cidrStr,''); if(descr===null) break;
 site.allocations.push({cidr:cidrStr,description:descr,vlan:null,created:new Date().toISOString()}); save(); renderSite(); break; }
 }});

 document.getElementById('importBtn').addEventListener('click',()=>{ document.getElementById('fileInput').click(); });
 document.getElementById('exportBtn').addEventListener('click',()=>{ const json=JSON.stringify(state,null,2); const blob=new Blob([json],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='cidr_normand_export.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); });
 document.getElementById('loadLocalBtn').addEventListener('click',()=>{ const el=document.getElementById('fileInput'); if(el) el.click(); });

 const _fileInput = document.getElementById('fileInput');
 if(_fileInput){
 const oldListener = _fileInput._changeHandler;
 if(oldListener) _fileInput.removeEventListener('change', oldListener);
 const changeHandler = ev => {
 const f = ev.target.files[0]; if(!f) return;
 const r = new FileReader();
 r.onload = () => {
 try{
 const j = JSON.parse(r.result);
 if(j && j.sites && Array.isArray(j.sites)){
 if(state && state.sites && state.sites.length>0){
 if(!confirm('Remplacer '+state.sites.length+' site(s) actuel(s) avec '+j.sites.length+' site(s) du fichier ?')){ return; }
 }
 state = j; save(); selectedSiteId = state.sites.length >0 ? state.sites[0].id : null; renderSites(); renderSite();
 const d = document.getElementById('debug'); if(d){ d.style.display='block'; d.textContent='Import OK'; }
 } else { throw new Error('Format invalide: objet JSON attendu avec propriété "sites"'); }
 }catch(err){ const d = document.getElementById('debug'); if(d){ d.style.display='block'; d.textContent='Import failed: '+(err && err.message?err.message:err); } }
 };
 r.readAsText(f);
 };
 _fileInput._changeHandler = changeHandler;
 _fileInput.addEventListener('change', changeHandler);
 }

 document.getElementById('bulkAddBtn').addEventListener('click',()=>{
 const txt = document.getElementById('bulkInput').value.trim(); if(!txt){ alert('Collez des lignes depuis Excel (format: VLAN tab NAME tab NETWORK tab MASK)'); return; }
 const site = findSite(selectedSiteId); if(!site){ alert('Sélectionnez un site'); return; }
 const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
 const results = [];
 for(const line of lines){
 let parts = line.split('\t').map(p=>p.trim()).filter(p=>p.length>0);
 if(parts.length <3) parts = line.split(/\s{2,}/).map(p=>p.trim()).filter(p=>p.length>0);
 if(parts.length <3) parts = line.split(/\s*[|;]\s*/).map(p=>p.trim()).filter(p=>p.length>0);
 if(parts.length <3){ results.push({line,ok:false,err:'Format invalide - minimum3 colonnes requises (VLAN, NAME, NETWORK)'}); continue; }
 const vlan = parts[0].trim(); const name = parts[1].trim(); const net = parts[2].trim(); const mask = parts[3] ? parts[3].trim() : '';
 let input = net + (mask ? ('/' + mask) : '');
 try{
 const cidr = normalizeCidr(input); const a = parseCidr(cidr); const root = parseCidr(site.rootCidr);
 if(a.network < root.network || a.broadcast > root.broadcast){ results.push({line,ok:false,err:'Hors du root'}); continue; }
 const overlap = site.allocations.some(x=>{ const r = parseCidr(x.cidr); return !(a.broadcast < r.network || a.network > r.broadcast); });
 if(overlap){ results.push({line,ok:false,err:'Chevauchement'}); continue; }
 site.allocations.push({cidr: cidr, vlan: vlan || null, description: name, created: new Date().toISOString()}); results.push({line,ok:true,cidr:cidr});
 }catch(e){ results.push({line,ok:false,err: e && e.message ? e.message : String(e)}); }
 }
 save(); renderSite();
 const okCount = results.filter(r=>r.ok).length; const errCount = results.length - okCount;
 const dbg = document.getElementById('debug'); if(dbg){ dbg.style.display='block'; dbg.textContent = `Bulk add: ${okCount} ajouté(s), ${errCount} erreur(s).` + (errCount ? '\nErreurs: ' + results.filter(r=>!r.ok).map(r=>r.line.substring(0,30) + '... : ' + r.err).join(' | ') : ''); }
 if(okCount >0) { document.getElementById('bulkInput').value = ''; }
 });

 }catch(e){ console.error('Event binding error',e); }
}

// Init
load(); if(state.sites && state.sites.length>0) selectedSiteId = state.sites[0].id; bindEvents(); renderSites(); renderSite();
// Rerender responsive bar on resize (debounced)
let __rszT; window.addEventListener('resize', ()=>{ clearTimeout(__rszT); __rszT = setTimeout(()=>{ if(selectedSiteId){ renderSite(); } },150); });
</script>
</body>
</html>
